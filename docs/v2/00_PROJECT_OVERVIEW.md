# Vibe Pay 개발 사양서: 0. 프로젝트 개요

## 1. 프로젝트 목적 및 핵심 가치

**Vibe Pay**는 다양한 결제 게이트웨이(PG)를 유연하게 통합하고, 포인트와 같은 자체 결제 수단을 함께 사용할 수 있는 확장 가능한 결제 시스템을 구축하는 것을 목표로 한다.

- **핵심 가치**:
    - **PG 유연성**: 특정 PG사에 종속되지 않고, 비즈니스 요구에 따라 새로운 PG사를 쉽게 추가하거나 트래픽을 분산할 수 있다.
    - **통합 결제 경험**: 신용카드 등 외부 결제 수단과 내부 포인트(마일리지)를 복합적으로 사용하는 결제 시나리오를 원활하게 지원한다.
    - **안정성 및 데이터 정합성**: 결제 과정에서 발생할 수 있는 다양한 예외(네트워크 오류, 사용자 이탈 등) 상황에서도 결제 데이터의 정합성을 보장하고, 모든 상호작용을 추적할 수 있는 로그 시스템을 갖춘다.
    - **명확한 역할 분리**: 클라이언트, 백엔드, PG사 간의 역할을 명확히 분리하여 각자의 책임에 집중할 수 있는 아키텍처를 지향한다.

## 2. 주요 사용자 시나리오 (User Story)

1.  **As a 사용자,** 나는 주문할 상품과 사용할 포인트를 선택한 후, 신용카드로 나머지 금액을 결제하여 주문을 완료하고 싶다.
2.  **As a 관리자,** 나는 특정 PG사의 장애 발생 시, 트래픽을 다른 PG사로 즉시 전환하여 결제 실패를 최소화하고 싶다.
3.  **As a 개발자,** 나는 PG사 연동 명세가 변경되거나 새로운 PG사를 추가해야 할 때, 시스템의 다른 부분에 영향을 주지 않고 해당 부분만 수정 또는 확장하고 싶다.
4.  **As a CS 담당자,** 나는 고객의 결제 실패 원인을 파악하기 위해, 우리 서버와 PG사 간의 모든 요청 및 응답 기록을 명확하게 조회하고 싶다.

## 3. 기술 스택 및 아키텍처

### 3.1. 아키텍처

본 프로젝트는 명확한 역할 분리를 위해 **프론트엔드(클라이언트)**와 **백엔드(서버)**로 분리된 **헤드리스(Headless) 아키텍처**를 채택한다.

```mermaid
graph TD
    subgraph "사용자 디바이스"
        A[프론트엔드 (Nuxt.js)]
    end

    subgraph "Vibe Pay 시스템"
        B[백엔드 API 서버 (Spring Boot)]
    end

    subgraph "외부 시스템"
        C[결제 게이트웨이 (Inicis, NicePay 등)]
        D[데이터베이스 (PostgreSQL)]
    end

    A --"1. 결제 준비 요청 (REST API)"--> B
    B --"2. PG 연동 파라미터 반환"--> A
    A --"3. PG 결제창 호출"--> C
    C --"4. 결제 결과 리디렉션"--> A
    A --"5. 최종 승인 요청 (REST API)"--> B
    B --"6. 서버 간 승인 (S2S)"--> C
    B --"7. 데이터 저장/조회"--> D
    C --"8. 승인 결과 반환"--> B
    B --"9. 최종 결과 반환"--> A
```

-   **프론트엔드**: 사용자 인터페이스와 PG사 결제창 연동의 매개체 역할을 담당한다. 백엔드로부터 받은 데이터로 PG사 결제 모듈을 호출하고, 그 결과를 다시 백엔드로 전달하는 책임을 가진다.
-   **백엔드**: 모든 비즈니스 로직, 데이터 검증, PG사와의 서버 간 통신(S2S), 데이터베이스 트랜잭션을 책임진다. 결제의 최종 승인과 취소는 반드시 백엔드를 통해서만 이루어진다.
-   **결제 게이트웨이(PG)**: 실제 카드사, 은행 등과 통신하여 금융 거래를 처리하는 외부 시스템이다.

### 3.2. 기술 스택 결정 근거

| 구분 | 기술 | 선정 이유 |
| :--- | :--- | :--- |
| **백엔드** | **Spring Boot (Java 17)** | - **안정성 및 생태계**: 금융 관련 로직 처리에 필수적인 트랜잭션 관리, 보안 기능이 검증되었고, 풍부한 라이브러리 생태계를 통해 안정적인 개발이 가능하다.<br>- **성능**: 멀티스레드 환경에서의 높은 처리량과 안정적인 성능을 제공하여 다수의 동시 결제 요청을 처리하기에 적합하다.<br>- **WebFlux**: PG사와의 서버 간 통신(S2S) 시, 비동기 Non-Blocking I/O를 통해 외부 API 호출 중 서버 자원을 효율적으로 사용하고 응답성을 높일 수 있다. |
| | **MyBatis** | - **SQL 제어권**: 복잡한 조인이나 통계 쿼리 등, SQL을 직접 제어해야 하는 경우에 유연성을 제공한다. `*Mapper.xml`을 통해 SQL과 코드를 분리하여 관리할 수 있다.<br>- **JPA 대비**: 상대적으로 러닝 커브가 낮고, 객체-관계 매핑의 복잡성 없이 데이터베이스 테이블 구조에 더 가깝게 작업할 수 있어 선택되었다. |
| | **PostgreSQL** | - **신뢰성 및 트랜잭션**: ACID를 완벽하게 지원하는 RDBMS로, 결제 데이터의 정합성을 보장하는 데 필수적이다.<br>- **오픈소스**: 라이선스 비용 없이 강력한 기능을 사용할 수 있으며, 활발한 커뮤니티와 풍부한 자료를 보유하고 있다. |
| **프론트엔드**| **Nuxt.js (Vue.js)** | - **생산성**: Vue.js 기반의 프레임워크로, 직관적인 문법과 잘 구축된 생태계를 통해 빠르게 UI를 개발할 수 있다.<br>- **서버 사이드 렌더링(SSR)**: 필요 시 SEO 최적화나 초기 로딩 성능 개선에 유리한 구조를 제공한다.<br>- **파일 기반 라우팅**: 페이지와 라우트 구조가 직관적으로 매핑되어 유지보수가 용이하다. |
| **인프라** | **환경변수 기반 설정** | - `application.yml`에서 볼 수 있듯이, PG사 연동 정보(`mid`, `apiKey` 등)를 환경변수로 주입받는 구조를 채택했다.<br>- 이를 통해 소스 코드의 변경 없이 개발, 스테이징, 운영 환경에 맞는 설정을 유연하게 변경할 수 있으며, 민감한 정보를 코드와 분리하여 보안을 강화한다. |
